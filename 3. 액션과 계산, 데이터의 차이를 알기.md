# 3. 액션과 계산, 데이터의 차이를 알기

## 액션과 계산, 데이터

함수형 프로그래머는 액션과 계산, 데이터를 구분한다.

> 액션

- 실행 시점과 횟수에 의존
- 부수 효과, 부수 효과가 있는 함수, 순수하지 않은 함수
- 예) 이메일 보내기, 데이터베이스 읽기

> 계산

- 입력으로 출력을 계산
- 순수 함수, 수학 함수
- 예) 최댓값 찾기, 이메일 주소가 올바른지 확인

> 데이터

- 이벤트에 대한 사실
- 예) 사용자가 입력한 이메일 주소 

### 액션과 계산, 데이터를 구분하는 기술

1. 문제에 대해 생각할 때

 문제를 액션,계산,데이터로 나눠보면 코드를 작성할 때 특별히 주의해야 할 부분인 액션과 

 데이터로 처리해야 할 부분, 결정을 내려야 하는 계산 부분을 명확히 알 수 있다.

2. 코딩할 때
 
 함수형 프로그래머는 최대한 액션에서 계산을 빼내려고 한다.
 
 계산에서는 데이터를 분리할 수 있는지 생각해 보아야 한다.
 
 또한, 액션이 계산이 될 수 있는지, 계산은 데이터가 될 수 있는지 고민해야 한다.
 

3. 코드를 읽을 때

 코드를 읽을 때 액션과 계산, 데이터 중 어떤 것에 속하는지 잘 살평보아야 한다. 
 
 특히 액션은 시간에 의존하기 때문에 더 조심해야 하며, 언제나 숨어있는 액션까지도 찾아야 한다.
 
## 액션, 계산, 데이터의 적용

일상 생활인 장보기에 액션, 계산, 데이터 적용하기

```
     [장보기 과정]

- 냉장고 확인하기       | (액션)   | 냉장고를 확인하는 시점에 따라 냉정고에 제품이 다르기에 액션

- 운정해서 상점으로 가기  | (액션)   | 두번 운전해서 상점에 가면 연료가 2배로 든다.

- 필요한 것 구입하기     | (액션)   | 구입 시점에 따라 물건이 다 떨어질 수도 있기 때문에 구입 시점이 중요한 액션
 
- 운전해서 집으로 오기    | (액션)   | 이미 집이라면 집에 올 수 없기 때문에 언제 인지가 중요한 액션
```


### 모든 것이 액션으로 보이는 위 분류를 단계별로 알아보기

**냉장고 확인하기**

- 냉장고를 확인은 시점이 중요하기 때문에 액션
- 냉장고에 있는 제품은 데이터 이며 이것은 ***현재 재고*** 이기도 하다

**운전해서 상점으로 가기**

- 운전해서 상점을 가는것은 명확한 액션
- 하지만, 상점의 위치, 가는 경로는 데이터 이다.

**필요한 것 구입하기**

- 구입하는 행동은 액션
- 필요한 것을 구입하기 위해서는 데이터가 필요
- 필요한 재고 - 현재 재고 = 장보기 목록

자세하게 계속 나누다 보면 점점 복잡해진다고 생각할 수 있으나, 액션에 숨어 있는 다른 액션이나 계산 또는 데이터를 발견하기

위해 나눌 수 있는 만큼 나누는 것을 추천

## 정리

1. 액션과 계산, 데이터는 어디에나 적용할 수 있다.
2. 액션 안에는 계산과 데이터, 또 다른 액션이 숨어 있을지도 모른다.
3. 계산은 더 작은 계산과 데이터로 나누고 연결할 수 있다.
4. 데이터는 데이터만 조합할 수 있다.

## 데이터란?

### 데이터

데이터는 이벤트에 대한 사실, 일어난 일의 결과를 기록한 것이다.

### 데이터의 구현

자바스크립트에서는 기본 데이터 타입으로 구현한다.

숫자, 문자, 배열, 객체 같은것이며, 다른 언어에서는 더 정교한 방법으로 데이터를 만들 수 있다.

하스켈은 새로운 데이터 타읍을 정의해 도메인을 표현한다.

### 데이터에 의미 담기

데이터의 구조로 의미를 담을 수 있다.

예를들어 목록의 순서자 중요하면 순서를 보장하는 데이터 구조를 만들면 된다.

데이터 구조로 도메인을 표현할 수 있다.

### 불변성

함수형 프로그래머는 불변 데이터 구조를 만들기 위해 두 가지 원칙을 사용한다.

1. copy-on-write : 변경할 대 복사본을 만들다.
2. defensive copy : 보관하려고 하는 데이터의 복사본을 만든다.

### 데이터의 예시

- 구입하려는 음식 목록
- 이름
- 전화 번호

### 데이터의 장점

데이터는 데이터 자체로 할 수 있는것이 없다.
그래서 데이터는 데이터 그 자체로 이해할 수 있다.

1. 직력화 
 - 직렬화된 액션과 계산은 다른 곳에서 잘 동작할 것 이라는 보장이 없다.
 - 직렬화된 데이터는 전송하거나 디스크에 저장했다가 읽기 쉽다.
 - 직렬화된 데이터는 오랜 시간 정확성을 보장할 수 있다.

2. 동일성 비교
 - 계산이나 액션은 서로 비교하기 어렵다.
 - 데이터는 비교하기 쉽다.

3. 자유로운 해석
 - 데이터는 여러가지 방법으로 해석할 수 있다.
 - 접속 로그는 디버깅에도 사용되지만 모니터링을 위해서도 사용된다.

### 데이터의 단점

데이터는 유연하게 해석할 수 있지만, 해석이 반드시 필요하다는 점이 단점이다.
해석하지 않은 데이터는 쓸모없는 바이트일 뿐이다.

## 쿠폰 보내는 과정을 그려보기

### 1. 데이터베이스에서 구독자를 가져오기

쿠폰을 이메일로 보내려면 데이터베이스에서 구족자를 가져와야 한다. 이 단계는 ***액션*** 이다.

구독자는 계속 바뀌며, 지금 가져오는 구독자와 다음번 구독자가 다를 수 있다. 이는 실행 시점에 의존된다.

구독자를 데이터베이스에서 가져오면 사용자 목록을 얻을 수 있고 이는 ***데이터*** 이다.

```
     [액션]         [계산]  [데이터]         

DB에서 구독자 가져오기   ->   구독자 목록
```

### 2. 데이터베이스에서 쿠폰 목록 가져오기

데이터베이스에서 쿠폰 목록을 가져오는 것도  ***액션*** 에 해당한다.

쿠폰 데이터베이스는 계속 변경되기에 가져오는 시점이 중요하다.

가져온 쿠폰 목록은 ***데이터*** 이다.

```
     [액션]         [계산]  [데이터]         

DB에서 구독자 가져오기   ->   구독자 목록
DB에서 쿠폰목록 가져오기  ->    쿠폰 목록
```

### 3. 보내야 할 이메일 목록 만들기

이메일 목록은 다음 단계에서 사용할 데이터이다.

이메일 목록은 보내야 할 이메일을 계획한 결과이다.

### 4. 이메일 전송하기

앞서 만들어둔 이메일 목록을 순회하며 전송한다.

### 5. +@ 이메일 만드는 부분 자세히 살펴보기

함수형 프로그래머가 아니면 이메일을 보내기 전에 이메일 목록 전체를 미리 만드는 것이 이상하다 생각할 수 있다.

하지만, 함수형 프로그래밍에서는 자연스러운 방법이다.

```
[계산]                [데이터]

이메일 목록 계획하기 <- 구독자 목록
                    쿠폰 목록
                
                -> 이메일 목록
```

- 구독자 목록 데이터와 쿠폰 목록 데이터를 받아 계산한 결과는 이메일 목록이다.
- 함수형 프로그래머는 가능하면 액션을 쓰지않으며, 계산으로 바꿀 수 있는 액션은 변경하는 것이 좋다.
- 계산을 사용하는 이유는 테스트하기 쉽기 때문이다.
- 계산은 외부에 영향을 주지 않기 때문에 쉽게 테스트 가능하고, 여러번 테스트해도 문제가 없다.

**이메일 목록을 계획하는 계산을 더 작은 계산으로 나눠보자**

'good'쿠폰과 'best'쿠폰이 있다고 가졍한다면, 쿠폰 목록을 두가지로 나누어 계산할 수 있다.

 ```
 [계산]                    [데이터]
 
                  <-     구독자 목록 
 good 쿠폰 선택하기  ->     good 쿠폰 목록
 best 쿠폰 선택하기  ->     best 쿠폰 목록
 ```

어떤 구록자가 good쿠폰을 받을지 best쿠폰을 받을지 결정하는 계산을 빼낼수 있다.

```
[계산]                  [데이터]

                  <-   구독자
쿠폰 등급 결정하기     ->  쿠폰 등급
(count >= 10 이라는 특정 규칙 적용에 대한 계산)
```

모든 단계를 모으면 어떤 구독자가 어떤 이메일을 받을지 결정하는 계산을 만들수 있다.

```
[계산]                  [데이터]

                  <-   구독자
쿠폰 등급 결정하기     ->  쿠폰 등급

-------------------------------

                  <-   구독자
                  <-   good 쿠폰 목록
                  <-   best 쿠폰 목록
                  <-   쿠폰 등급
쿠폰 등급에 따른
이메일 만들기         ->   이메일
```


## 쿠폰 보내는 과정 구현

만들어진 다이어그램을 구현 한다.

### 데이터베이스에서 구독자를 가져오기

이메일 데이터베이스 테이블을 자바스크립트 객체로 표현한다.

```
# 이메일 데이터베이스 테이블
[email]                [rec_count]
john@coldmail.com           2
sam@pmail.com               16
linda1989@oal.com           1

# 자바스크립트 객체
const subscriber = {
 email : 'sma@pmail.com',
 rec_count : 16
};

```

### 문자열의 쿠폰등급

쿠폰 등급은 문자열로 표현한다.

```
# 쿠폰 데이터베이스 테이블
[code]        [rank]
MAYDISCOUNT    good
10PERCENT      best

# 자바스크립트 문자열
const rank1 = 'best';
const rank2 = 'good';
```

### 자바스크립트에서 계산은 함수로 구현한다

자바스크립트에서 계산은 함수로 구현한다. 입력값은 함수 인자 이고, 출력값은 return값이다.

계산 내용은 함수 본문이다.

계산은 입력값으로 출력밧을 만들며, 호출 시점이나 횟수에 의존하지 않고 동일한 입력값을 넣으면 

항상 동일한 출력값을 돌려준다.

```
function subCouponRank(subscriber) {
  if(subscriber.rec_count >= 10){
    return 'best';
  }else{
    return 'good';
  }
}
```

어떤 구독자가 어떤 등급의 쿠폰을 받을지 계산을 함수로 구현하였다.

### 데이터베이스에서 가져온 쿠폰 데이터

전체 쿠폰 목록에서 주어진 등급의 쿠폰 목록만 선택하는 부분을 구현한다.

 ```
 [계산]                    [데이터]
 
                  <-       쿠폰 목록 
 good 쿠폰 선택하기  ->     good 쿠폰 목록
 best 쿠폰 선택하기  ->     best 쿠폰 목록
 ```

쿠폰 데이터도 구독자 데이터와 같이 자바스크립트 객체로 표현한다.

```
# 쿠폰 데이터베이스 테이블
[code]        [rank]
MAYDISCOUNT    good
10PERCENT      best

# 자바스크립트 객체
const coupon = {
 code : '10PERCENT',
 rank : 'best'
};
```

### 특정 등급의 쿠폰 목옥을 선택하는 계산 함수

특정 등급의 쿠폰을 선택하는 계산도 함수로 구현한다.

입력값은 전체 쿠폰 목록과 선택할 등급, 출력값은 선택한 등급을 가진 쿠폰 목록

```
function selectCouponsByRank(coupons, rank) {
  let ret = [];

  for (let c = 0; c < coupons.length; c++) {
    const coupon = coupons[c];
    
    if(coupon.rank === rank){
      ret.push(coupon.code);
    }
  }

  return ret;
}
```

`selectCouponsByRank()`함수는 같은 입력값을 넣었을 때 항상 같은 값이 나오며, 

여러번 호출해도 외부에 어떠한 영향도 주지 않는다. 따라서 `selectCouponsByRank()`함수는 계산이다.

### 이메일을 데이터로 표현

```
const message = {
 from : 'newsletter@coupondog.co',
 to : 'sma@pmail.com',
 subject : 'your weekly coupons ...',
 body : '...'
};
```

### 구독자가 받을 이메일 계산 함수

필요 인자

- 구독자
- 쿠폰 목록
- 어떤 쿠폰을 사용할지 알수 없기에 good 쿠폰목록과 best 쿠폰목록

```
function emailForSubscriber(subscriber, goods, bests) {
  const rank = subCouponRnak(subscriber);

  if(rank === 'best'){
    return {
      from : 'newsletter@coupondog.co',
      to : subscriber.email,
      subject : '...',
      body : 'your coupons : ' + bests.join(', ')
    };
  }else{
    return {
      from : 'newsletter@coupondog.co',
      to : subscriber.email,
      subject : '...',
      body : 'your coupons : ' + goods.join(', ')
    };
  }
}
```

### 보낼 이메일 목록 계산 함수

구독자 목록으로 전체 이메일 목록을 만든다.

```
function emailsForSubscrivers(subscribers, goods, bests) {
  const emails = [];

  for (let s = 0; s < subscribers.length; s++) {
    const subscriber = subscribers[s];
    const email = emailForSubscriber(subscriber, goods, bests);

    emails.push(email);
  }

  return emails;
}
```

### 이메일 보내기 액션

액션으로 모든 계산 기능을 하나로 묶는다.

```
function sendIssue() {
  const coupons = fetchCouponsFromDb();
  const goodCoupons = selectCouponsByRank(coupons, 'good');
  const bestCoupons = selectCouponsByRank(coupons, 'best');
  const subscribers = fetchSubscribersFromDb();
  const emails = emailsForSubscrivers(subscribers, goodCoupons, bestCoupons);

  for (let e = 0; e < array.length; e++) {
    const email = emails[e];
    
    emailSystem.send(email);
  }
}
```

데이터를 파악하는 것으로 시작하여, 계산과 추가 데이터를 도출하고 애션으로 모든것을 묶었다.

이와 같이 데이터를 먼저 구현하고 계산을 구현한 후에 마지막으로 액션을 구현하는 것이

함수형 프로그래밍의 일반적인 구현 순서 이다.

**일반적인 구현 순서**

1. 데이터
2. 계산
3. 액션


